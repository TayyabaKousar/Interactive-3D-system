<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hand Controlled Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-input { position: absolute; top: 10px; left: 10px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); opacity: 0.5; border-radius: 8px; }
        #ui { position: absolute; bottom: 20px; left: 20px; color: white; font-family: sans-serif; z-index: 3; pointer-events: none; }
        .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-family: sans-serif; font-size: 24px; z-index: 4; }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading" class="loading">Loading AI Models...</div>
    <video id="video-input"></video>
    <div id="canvas-container"></div>
    <div id="ui">
        <h2>Interactive Particles</h2>
        <p>üñê Move Hand: Position</p>
        <p>ü§è Pinch (Thumb+Index): Expand/Contract</p>
        <p>‚úä Make a Fist: Switch Shape</p>
        <p id="current-shape">Current: Sphere</p>
    </div>

<script>
    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 8000;
    const PARTICLE_SIZE = 0.08;
    const SMOOTHING = 0.08; // How fast particles fly to target

    // --- THREE.JS SETUP ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    
    // Fog for depth
    scene.fog = new THREE.FogExp2(0x000000, 0.03);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 15;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // --- PARTICLE SYSTEM ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    
    // Store target positions for morphing
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3);

    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 20;
        colors[i] = 1;
        targetPositions[i] = positions[i];
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.8
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- SHAPE GENERATORS ---
    // Helper to set target positions based on math formulas
    const shapes = {
        sphere: () => {
            const label = "Sphere";
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = 4 + Math.random() * 0.5;
                
                targetPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                targetPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                targetPositions[i * 3 + 2] = r * Math.cos(phi);
            }
            return label;
        },
        heart: () => {
            const label = "Heart";
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Heart formula
                const t = Math.random() * Math.PI * 2;
                const r = Math.random(); // volume filler
                
                // x = 16sin^3(t)
                const x = 16 * Math.pow(Math.sin(t), 3);
                // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                
                // Extrude slightly in Z for 3D effect
                const z = (Math.random() - 0.5) * 4;

                const scale = 0.25;
                targetPositions[i * 3] = x * scale;
                targetPositions[i * 3 + 1] = y * scale;
                targetPositions[i * 3 + 2] = z;
            }
            return label;
        },
        saturn: () => {
            const label = "Saturn";
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // 60% particles for planet, 40% for rings
                if (i < PARTICLE_COUNT * 0.6) {
                    // Planet
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const r = 2.5;
                    targetPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                    targetPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    targetPositions[i * 3 + 2] = r * Math.cos(phi);
                } else {
                    // Rings
                    const angle = Math.random() * Math.PI * 2;
                    const r = 4 + Math.random() * 2; // Radius between 4 and 6
                    targetPositions[i * 3] = r * Math.cos(angle);
                    targetPositions[i * 3 + 1] = (Math.random() - 0.5) * 0.2; // Flat Y
                    targetPositions[i * 3 + 2] = r * Math.sin(angle);
                }
            }
            return label;
        },
        flower: () => {
            const label = "Flower";
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                // Rose curve logic roughly
                const r = 3 + Math.sin(5 * u) * 2; 
                
                targetPositions[i * 3] = r * Math.cos(u) * Math.sin(v);
                targetPositions[i * 3 + 1] = r * Math.sin(u) * Math.sin(v);
                targetPositions[i * 3 + 2] = r * Math.cos(v) * 0.5; // Flatten z
            }
            return label;
        },
        fireworks: () => {
            const label = "Fireworks";
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                // Heavy distribution at center, trails outward
                const r = Math.pow(Math.random(), 3) * 8; 
                
                targetPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                targetPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                targetPositions[i * 3 + 2] = r * Math.cos(phi);
            }
            return label;
        }
    };

    const shapeKeys = Object.keys(shapes);
    let currentShapeIndex = 0;
    
    // Initialize first shape
    shapes[shapeKeys[0]]();

    function nextShape() {
        currentShapeIndex = (currentShapeIndex + 1) % shapeKeys.length;
        const name = shapes[shapeKeys[currentShapeIndex]]();
        document.getElementById('current-shape').innerText = `Current: ${name}`;
    }

    // --- INTERACTION STATE ---
    let handX = 0, handY = 0;
    let expansionFactor = 1;
    let isHandPresent = false;
    let lastGestureTime = 0;
    let isFist = false;

    // --- MEDIAPIPE SETUP ---
    const videoElement = document.getElementById('video-input');
    
    function onResults(results) {
        document.getElementById('loading').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            isHandPresent = true;
            const landmarks = results.multiHandLandmarks[0];

            // 1. Position Tracking (Use Wrist #0 or Index MCP #5)
            // Map 0-1 video coords to -10 to 10 world coords
            // Note: Video is mirrored via CSS, but data isn't.
            // We flip X logic here: (1 - x)
            const x = (1 - landmarks[9].x) * 2 - 1; 
            const y = -(landmarks[9].y * 2 - 1);

            // Smooth hand movement
            handX += (x * 10 - handX) * 0.1;
            handY += (y * 8 - handY) * 0.1;

            // 2. Pinch Detection (Index Tip #8 vs Thumb Tip #4)
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            
            // Map distance to expansion (Close = 0.5, Open = 2.0)
            const targetExpansion = THREE.MathUtils.mapLinear(distance, 0.02, 0.15, 0.5, 2.5);
            expansionFactor += (targetExpansion - expansionFactor) * 0.1;

            // 3. Gesture Detection (Fist for shape switching)
            // Check if fingertips are below knuckles (roughly a fist)
            const tips = [8, 12, 16, 20];
            const mcp = [5, 9, 13, 17];
            let foldedFingers = 0;
            tips.forEach((tipIdx, i) => {
                // If tip is below MCP (in screen Y coords, higher value is lower on screen)
                if (landmarks[tipIdx].y > landmarks[mcp[i]].y) foldedFingers++;
            });

            // Trigger switch if fist is held, but debounce it
            const now = Date.now();
            if (foldedFingers >= 3) {
                if (!isFist && now - lastGestureTime > 1000) {
                    nextShape();
                    lastGestureTime = now;
                    isFist = true;
                }
            } else {
                isFist = false;
            }

        } else {
            isHandPresent = false;
            // Return to center if no hand
            handX += (0 - handX) * 0.05;
            handY += (0 - handY) * 0.05;
            expansionFactor += (1 - expansionFactor) * 0.05;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320,
        height: 240
    });
    cameraUtils.start();

    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();
    const tempColor = new THREE.Color();

    function animate() {
        requestAnimationFrame(animate);
        
        const time = clock.getElapsedTime();
        const positionsArr = particles.geometry.attributes.position.array;
        const colorsArr = particles.geometry.attributes.color.array;

        // Rotate entire system slowly
        particles.rotation.y = time * 0.1;
        particles.rotation.z = time * 0.05;

        // Dynamic Hue based on hand position
        const baseHue = (time * 0.1) % 1;
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;

            // Get target position for the current shape
            let tx = targetPositions[i3];
            let ty = targetPositions[i3 + 1];
            let tz = targetPositions[i3 + 2];

            // Apply Expansion (Explosion effect based on Pinch)
            tx *= expansionFactor;
            ty *= expansionFactor;
            tz *= expansionFactor;

            // Apply Hand Translation (Move particles to hand)
            tx += handX;
            ty += handY;

            // Current Position
            let cx = positionsArr[i3];
            let cy = positionsArr[i3 + 1];
            let cz = positionsArr[i3 + 2];

            // Noise/Wiggle effect
            cx += (Math.random() - 0.5) * 0.05;
            cy += (Math.random() - 0.5) * 0.05;
            cz += (Math.random() - 0.5) * 0.05;

            // Linear Interpolation (Lerp) towards target for smooth transition
            positionsArr[i3] += (tx - cx) * SMOOTHING;
            positionsArr[i3 + 1] += (ty - cy) * SMOOTHING;
            positionsArr[i3 + 2] += (tz - cz) * SMOOTHING;

            // Color Logic: Gradient based on distance from center relative to hand
            // Calculate distance from particle to hand center
            const dist = Math.sqrt(Math.pow(positionsArr[i3]-handX, 2) + Math.pow(positionsArr[i3+1]-handY, 2));
            
            // Hue shifts based on distance and time
            const h = (baseHue + (dist * 0.05)) % 1; 
            const s = 0.8;
            const l = isFist ? 0.8 : 0.5; // Brighter when switching shapes

            tempColor.setHSL(h, s, l);
            
            colorsArr[i3] = tempColor.r;
            colorsArr[i3 + 1] = tempColor.g;
            colorsArr[i3 + 2] = tempColor.b;
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.geometry.attributes.color.needsUpdate = true;

        renderer.render(scene, camera);
    }

    // Handle Window Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
</body>
</html>